<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROS2 Control: controller_interface::ControllerInterfaceBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROS2 Control
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>controller_interface</b></li><li class="navelem"><a class="el" href="classcontroller__interface_1_1ControllerInterfaceBase.html">ControllerInterfaceBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcontroller__interface_1_1ControllerInterfaceBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">controller_interface::ControllerInterfaceBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="controller__interface__base_8hpp_source.html">controller_interface_base.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for controller_interface::ControllerInterfaceBase:</div>
<div class="dyncontent">
<div class="center"><img src="classcontroller__interface_1_1ControllerInterfaceBase__inherit__graph.png" border="0" usemap="#acontroller__interface_1_1ControllerInterfaceBase_inherit__map" alt="Inheritance graph"/></div>
<map name="acontroller__interface_1_1ControllerInterfaceBase_inherit__map" id="acontroller__interface_1_1ControllerInterfaceBase_inherit__map">
<area shape="rect" title=" " alt="" coords="305,161,489,203"/>
<area shape="rect" href="classcontroller__interface_1_1ChainableControllerInterface.html" title=" " alt="" coords="537,71,755,112"/>
<area shape="rect" href="classcontroller__interface_1_1ControllerInterface.html" title=" " alt="" coords="570,245,722,287"/>
<area shape="rect" title=" " alt="" coords="5,161,257,203"/>
<area shape="rect" href="classTestableChainableControllerInterface.html" title=" " alt="" coords="807,5,1013,47"/>
<area shape="rect" href="classtest__chainable__controller_1_1TestChainableController.html" title=" " alt="" coords="817,71,1003,112"/>
<area shape="rect" href="classTestableTestChainableController.html" title=" " alt="" coords="1065,74,1296,101"/>
<area shape="rect" href="classControllerMock.html" title=" " alt="" coords="849,143,971,170"/>
<area shape="rect" href="classTestableControllerInterface.html" title=" " alt="" coords="811,194,1009,221"/>
<area shape="rect" href="classcontroller__with__options_1_1ControllerWithOptions.html" title=" " alt="" coords="823,245,997,287"/>
<area shape="rect" href="classtest__controller_1_1TestController.html" title=" " alt="" coords="803,311,1017,338"/>
<area shape="rect" href="classtest__controller__failed__init_1_1TestControllerFailedInit.html" title=" " alt="" coords="807,363,1013,404"/>
<area shape="rect" href="classtest__controller__with__interfaces_1_1TestControllerWithInterfaces.html" title=" " alt="" coords="814,429,1006,485"/>
<area shape="rect" href="classTestableControllerInterfaceInitError.html" title=" " alt="" coords="1081,125,1280,167"/>
<area shape="rect" href="classTestableControllerInterfaceInitFailure.html" title=" " alt="" coords="1081,191,1280,232"/>
<area shape="rect" href="classFriendControllerWithOptions.html" title=" " alt="" coords="1077,257,1284,283"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for controller_interface::ControllerInterfaceBase:</div>
<div class="dyncontent">
<div class="center"><img src="classcontroller__interface_1_1ControllerInterfaceBase__coll__graph.png" border="0" usemap="#acontroller__interface_1_1ControllerInterfaceBase_coll__map" alt="Collaboration graph"/></div>
<map name="acontroller__interface_1_1ControllerInterfaceBase_coll__map" id="acontroller__interface_1_1ControllerInterfaceBase_coll__map">
<area shape="rect" title=" " alt="" coords="39,95,223,136"/>
<area shape="rect" title=" " alt="" coords="5,5,257,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7241e933b6cb95b3304a49c8a6830aa6"><td class="memItemLeft" align="right" valign="top">virtual CONTROLLER_INTERFACE_PUBLIC <a class="el" href="structcontroller__interface_1_1InterfaceConfiguration.html">InterfaceConfiguration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontroller__interface_1_1ControllerInterfaceBase.html#a7241e933b6cb95b3304a49c8a6830aa6">command_interface_configuration</a> () const =0</td></tr>
<tr class="memdesc:a7241e933b6cb95b3304a49c8a6830aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get configuration for controller's required command interfaces.  <a href="classcontroller__interface_1_1ControllerInterfaceBase.html#a7241e933b6cb95b3304a49c8a6830aa6">More...</a><br /></td></tr>
<tr class="separator:a7241e933b6cb95b3304a49c8a6830aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3417ed9b9990df177ab116f9a7147b74"><td class="memItemLeft" align="right" valign="top">virtual CONTROLLER_INTERFACE_PUBLIC <a class="el" href="structcontroller__interface_1_1InterfaceConfiguration.html">InterfaceConfiguration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontroller__interface_1_1ControllerInterfaceBase.html#a3417ed9b9990df177ab116f9a7147b74">state_interface_configuration</a> () const =0</td></tr>
<tr class="memdesc:a3417ed9b9990df177ab116f9a7147b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get configuration for controller's required state interfaces.  <a href="classcontroller__interface_1_1ControllerInterfaceBase.html#a3417ed9b9990df177ab116f9a7147b74">More...</a><br /></td></tr>
<tr class="separator:a3417ed9b9990df177ab116f9a7147b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab651c47c448485ac058c50fe888b9fd1"><td class="memItemLeft" align="right" valign="top"><a id="ab651c47c448485ac058c50fe888b9fd1"></a>
CONTROLLER_INTERFACE_PUBLIC void&#160;</td><td class="memItemRight" valign="bottom"><b>assign_interfaces</b> (std::vector&lt; <a class="el" href="classhardware__interface_1_1LoanedCommandInterface.html">hardware_interface::LoanedCommandInterface</a> &gt; &amp;&amp;command_interfaces, std::vector&lt; <a class="el" href="classhardware__interface_1_1LoanedStateInterface.html">hardware_interface::LoanedStateInterface</a> &gt; &amp;&amp;state_interfaces)</td></tr>
<tr class="separator:ab651c47c448485ac058c50fe888b9fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78343670e39b1f1cc969c6decd9de637"><td class="memItemLeft" align="right" valign="top"><a id="a78343670e39b1f1cc969c6decd9de637"></a>
CONTROLLER_INTERFACE_PUBLIC void&#160;</td><td class="memItemRight" valign="bottom"><b>release_interfaces</b> ()</td></tr>
<tr class="separator:a78343670e39b1f1cc969c6decd9de637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b29ab11cfd8eb472a58b16c0a24f00e"><td class="memItemLeft" align="right" valign="top"><a id="a8b29ab11cfd8eb472a58b16c0a24f00e"></a>
virtual CONTROLLER_INTERFACE_PUBLIC return_type&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> (const std::string &amp;controller_name, const std::string &amp;namespace_=&quot;&quot;, const rclcpp::NodeOptions &amp;node_options=rclcpp::NodeOptions())</td></tr>
<tr class="separator:a8b29ab11cfd8eb472a58b16c0a24f00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7ab0f474471aaa0e931ea8fe840bcc"><td class="memItemLeft" align="right" valign="top"><a id="a9e7ab0f474471aaa0e931ea8fe840bcc"></a>
CONTROLLER_INTERFACE_PUBLIC const rclcpp_lifecycle::State &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontroller__interface_1_1ControllerInterfaceBase.html#a9e7ab0f474471aaa0e931ea8fe840bcc">configure</a> ()</td></tr>
<tr class="memdesc:a9e7ab0f474471aaa0e931ea8fe840bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom configure method to read additional parameters for controller-nodes. <br /></td></tr>
<tr class="separator:a9e7ab0f474471aaa0e931ea8fe840bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352fede6a3954e3bd497399ead0b9df5"><td class="memItemLeft" align="right" valign="top"><a id="a352fede6a3954e3bd497399ead0b9df5"></a>
virtual CONTROLLER_INTERFACE_PUBLIC CallbackReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontroller__interface_1_1ControllerInterfaceBase.html#a352fede6a3954e3bd497399ead0b9df5">on_init</a> ()=0</td></tr>
<tr class="memdesc:a352fede6a3954e3bd497399ead0b9df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extending interface with initialization method which is individual for each controller. <br /></td></tr>
<tr class="separator:a352fede6a3954e3bd497399ead0b9df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1fed599ea8a49a696ea657bf6a02b1"><td class="memItemLeft" align="right" valign="top">virtual CONTROLLER_INTERFACE_PUBLIC return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontroller__interface_1_1ControllerInterfaceBase.html#add1fed599ea8a49a696ea657bf6a02b1">update</a> (const rclcpp::Time &amp;time, const rclcpp::Duration &amp;period)=0</td></tr>
<tr class="separator:add1fed599ea8a49a696ea657bf6a02b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03633f8fc5280c1894c29688ab4971c5"><td class="memItemLeft" align="right" valign="top"><a id="a03633f8fc5280c1894c29688ab4971c5"></a>
CONTROLLER_INTERFACE_PUBLIC std::shared_ptr&lt; rclcpp_lifecycle::LifecycleNode &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_node</b> ()</td></tr>
<tr class="separator:a03633f8fc5280c1894c29688ab4971c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5a8fb8b468f54cbfdbe0e35bce9450"><td class="memItemLeft" align="right" valign="top"><a id="a9e5a8fb8b468f54cbfdbe0e35bce9450"></a>
CONTROLLER_INTERFACE_PUBLIC std::shared_ptr&lt; rclcpp_lifecycle::LifecycleNode &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_node</b> () const</td></tr>
<tr class="separator:a9e5a8fb8b468f54cbfdbe0e35bce9450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b056befd1a5a80c0e8531c7789c438"><td class="memItemLeft" align="right" valign="top"><a id="a97b056befd1a5a80c0e8531c7789c438"></a>
CONTROLLER_INTERFACE_PUBLIC const rclcpp_lifecycle::State &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_state</b> () const</td></tr>
<tr class="separator:a97b056befd1a5a80c0e8531c7789c438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312f99066d6c15f47b195cda4624ba78"><td class="memItemLeft" align="right" valign="top"><a id="a312f99066d6c15f47b195cda4624ba78"></a>
CONTROLLER_INTERFACE_PUBLIC unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>get_update_rate</b> () const</td></tr>
<tr class="separator:a312f99066d6c15f47b195cda4624ba78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04df56d589677c015eb11930d66bbfe4"><td class="memTemplParams" colspan="2">template&lt;typename ParameterT &gt; </td></tr>
<tr class="memitem:a04df56d589677c015eb11930d66bbfe4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontroller__interface_1_1ControllerInterfaceBase.html#a04df56d589677c015eb11930d66bbfe4">auto_declare</a> (const std::string &amp;name, const ParameterT &amp;default_value)</td></tr>
<tr class="memdesc:a04df56d589677c015eb11930d66bbfe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare and initialize a parameter with a type.  <a href="classcontroller__interface_1_1ControllerInterfaceBase.html#a04df56d589677c015eb11930d66bbfe4">More...</a><br /></td></tr>
<tr class="separator:a04df56d589677c015eb11930d66bbfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ce72576b7d96af3909f385ccb9e8be"><td class="memItemLeft" align="right" valign="top">virtual CONTROLLER_INTERFACE_PUBLIC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontroller__interface_1_1ControllerInterfaceBase.html#ad5ce72576b7d96af3909f385ccb9e8be">is_chainable</a> () const =0</td></tr>
<tr class="memdesc:ad5ce72576b7d96af3909f385ccb9e8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information if a controller is chainable.  <a href="classcontroller__interface_1_1ControllerInterfaceBase.html#ad5ce72576b7d96af3909f385ccb9e8be">More...</a><br /></td></tr>
<tr class="separator:ad5ce72576b7d96af3909f385ccb9e8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9f2eae233f96dd1f51424b66dc3dda"><td class="memItemLeft" align="right" valign="top">virtual CONTROLLER_INTERFACE_PUBLIC std::vector&lt; <a class="el" href="classhardware__interface_1_1CommandInterface.html">hardware_interface::CommandInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontroller__interface_1_1ControllerInterfaceBase.html#a0e9f2eae233f96dd1f51424b66dc3dda">export_reference_interfaces</a> ()=0</td></tr>
<tr class="separator:a0e9f2eae233f96dd1f51424b66dc3dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c8cc3ea5aaec0ca36d8aa8b20b433c"><td class="memItemLeft" align="right" valign="top">virtual CONTROLLER_INTERFACE_PUBLIC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontroller__interface_1_1ControllerInterfaceBase.html#a56c8cc3ea5aaec0ca36d8aa8b20b433c">set_chained_mode</a> (bool chained_mode)=0</td></tr>
<tr class="separator:a56c8cc3ea5aaec0ca36d8aa8b20b433c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d052e19a586221d71318391515a5714"><td class="memItemLeft" align="right" valign="top">virtual CONTROLLER_INTERFACE_PUBLIC bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontroller__interface_1_1ControllerInterfaceBase.html#a8d052e19a586221d71318391515a5714">is_in_chained_mode</a> () const =0</td></tr>
<tr class="memdesc:a8d052e19a586221d71318391515a5714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information if a controller is currently in chained mode.  <a href="classcontroller__interface_1_1ControllerInterfaceBase.html#a8d052e19a586221d71318391515a5714">More...</a><br /></td></tr>
<tr class="separator:a8d052e19a586221d71318391515a5714"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0f83186fc95e9ae8b27ee0ad29e5f148"><td class="memItemLeft" align="right" valign="top"><a id="a0f83186fc95e9ae8b27ee0ad29e5f148"></a>
std::vector&lt; <a class="el" href="classhardware__interface_1_1LoanedCommandInterface.html">hardware_interface::LoanedCommandInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>command_interfaces_</b></td></tr>
<tr class="separator:a0f83186fc95e9ae8b27ee0ad29e5f148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffb684790a208ce8d81af90be0cdd9c"><td class="memItemLeft" align="right" valign="top"><a id="abffb684790a208ce8d81af90be0cdd9c"></a>
std::vector&lt; <a class="el" href="classhardware__interface_1_1LoanedStateInterface.html">hardware_interface::LoanedStateInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>state_interfaces_</b></td></tr>
<tr class="separator:abffb684790a208ce8d81af90be0cdd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f05708e13e7368b4cea7d9cbb57e920"><td class="memItemLeft" align="right" valign="top"><a id="a9f05708e13e7368b4cea7d9cbb57e920"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>update_rate_</b> = 0</td></tr>
<tr class="separator:a9f05708e13e7368b4cea7d9cbb57e920"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base interface class for an controller. The interface may not be used to implement a controller. The class provides definitions for <code><a class="el" href="classcontroller__interface_1_1ControllerInterface.html">ControllerInterface</a></code> and <code><a class="el" href="classcontroller__interface_1_1ChainableControllerInterface.html">ChainableControllerInterface</a></code> that should be implemented and extended for a specific controller. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a04df56d589677c015eb11930d66bbfe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04df56d589677c015eb11930d66bbfe4">&#9670;&nbsp;</a></span>auto_declare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParameterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto controller_interface::ControllerInterfaceBase::auto_declare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParameterT &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declare and initialize a parameter with a type. </p>
<p>Wrapper function for templated node's declare_parameter() which checks if parameter is already declared. For use in all components that inherit from <a class="el" href="classcontroller__interface_1_1ControllerInterfaceBase.html">ControllerInterfaceBase</a> </p>

</div>
</div>
<a id="a7241e933b6cb95b3304a49c8a6830aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7241e933b6cb95b3304a49c8a6830aa6">&#9670;&nbsp;</a></span>command_interface_configuration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CONTROLLER_INTERFACE_PUBLIC <a class="el" href="structcontroller__interface_1_1InterfaceConfiguration.html">InterfaceConfiguration</a> controller_interface::ControllerInterfaceBase::command_interface_configuration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get configuration for controller's required command interfaces. </p>
<p>Method used by the controller_manager to get the set of command interfaces used by the controller. Each controller can use individual method to determine interface names that in simples case have the following format: <code>&lt;joint&gt;/&lt;interface&gt;</code>. The method is called only in <code>inactive</code> or <code>active</code> state, i.e., <code>on_configure</code> has to be called first. The configuration is used to check if controller can be activated and to claim interfaces from hardware. The claimed interfaces are populated in the command_interfaces_ member.</p>
<dl class="section return"><dt>Returns</dt><dd>configuration of command interfaces. </dd></dl>

<p>Implemented in <a class="el" href="classtest__controller__with__interfaces_1_1TestControllerWithInterfaces.html#aa794c152441a28f57486cbe1ff895a49">test_controller_with_interfaces::TestControllerWithInterfaces</a>, <a class="el" href="classtest__controller__failed__init_1_1TestControllerFailedInit.html#ab94ecbf1899fe9ec5e24ec1c2d8ea6dd">test_controller_failed_init::TestControllerFailedInit</a>, <a class="el" href="classtest__controller_1_1TestController.html#a4bf3edddf97444efffa4f233ebbb40d5">test_controller::TestController</a>, <a class="el" href="classtest__chainable__controller_1_1TestChainableController.html#afde701a5ba62dc1583756a6597e2afef">test_chainable_controller::TestChainableController</a>, <a class="el" href="classcontroller__with__options_1_1ControllerWithOptions.html#a027b6a5015307af7a27481822fed59e0">controller_with_options::ControllerWithOptions</a>, <a class="el" href="classTestableControllerInterface.html#af34083ca6ab5ee76beb1723fcd4b9f1f">TestableControllerInterface</a>, and <a class="el" href="classTestableChainableControllerInterface.html#a91b3ac64958c9aa022b133a64e91b5ee">TestableChainableControllerInterface</a>.</p>

</div>
</div>
<a id="a0e9f2eae233f96dd1f51424b66dc3dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9f2eae233f96dd1f51424b66dc3dda">&#9670;&nbsp;</a></span>export_reference_interfaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CONTROLLER_INTERFACE_PUBLIC std::vector&lt;<a class="el" href="classhardware__interface_1_1CommandInterface.html">hardware_interface::CommandInterface</a>&gt; controller_interface::ControllerInterfaceBase::export_reference_interfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export interfaces for a chainable controller that can be used as command interface of other controllers.</p>
<dl class="section return"><dt>Returns</dt><dd>list of command interfaces for preceding controllers. </dd></dl>

<p>Implemented in <a class="el" href="classcontroller__interface_1_1ControllerInterface.html#aa318f32026cf1dd22733a0ac48c623c0">controller_interface::ControllerInterface</a>, and <a class="el" href="classcontroller__interface_1_1ChainableControllerInterface.html#aa82394dd8f431cc065b2d1081483499a">controller_interface::ChainableControllerInterface</a>.</p>

</div>
</div>
<a id="ad5ce72576b7d96af3909f385ccb9e8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ce72576b7d96af3909f385ccb9e8be">&#9670;&nbsp;</a></span>is_chainable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CONTROLLER_INTERFACE_PUBLIC bool controller_interface::ControllerInterfaceBase::is_chainable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get information if a controller is chainable. </p>
<p>Get information if a controller is chainable.</p>
<dl class="section return"><dt>Returns</dt><dd>true is controller is chainable and false if it is not. </dd></dl>

<p>Implemented in <a class="el" href="classcontroller__interface_1_1ControllerInterface.html#a8f9df0485b8a65363fecf5a3ccc9f51d">controller_interface::ControllerInterface</a>, and <a class="el" href="classcontroller__interface_1_1ChainableControllerInterface.html#aca75cbab7693e216194b7c41aa12739d">controller_interface::ChainableControllerInterface</a>.</p>

</div>
</div>
<a id="a8d052e19a586221d71318391515a5714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d052e19a586221d71318391515a5714">&#9670;&nbsp;</a></span>is_in_chained_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CONTROLLER_INTERFACE_PUBLIC bool controller_interface::ControllerInterfaceBase::is_in_chained_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get information if a controller is currently in chained mode. </p>
<p>Get information about controller if it is currently used in chained mode. In chained mode only internal interfaces are available and all subscribers are expected to be disabled. This prevents concurrent writing to controller's inputs from multiple sources.</p>
<dl class="section return"><dt>Returns</dt><dd>true is controller is in chained mode and false if it is not. </dd></dl>

<p>Implemented in <a class="el" href="classcontroller__interface_1_1ControllerInterface.html#ac86232dee7173226b28b8ba5d0e2b44d">controller_interface::ControllerInterface</a>, and <a class="el" href="classcontroller__interface_1_1ChainableControllerInterface.html#a5add6d3d59bdf470ac241e07c62f4852">controller_interface::ChainableControllerInterface</a>.</p>

</div>
</div>
<a id="a56c8cc3ea5aaec0ca36d8aa8b20b433c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c8cc3ea5aaec0ca36d8aa8b20b433c">&#9670;&nbsp;</a></span>set_chained_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CONTROLLER_INTERFACE_PUBLIC bool controller_interface::ControllerInterfaceBase::set_chained_mode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chained_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set chained mode of a chainable controller. This method triggers internal processes to switch a chainable controller to "chained" mode and vice-versa. Setting controller to "chained" mode usually involves disabling of subscribers and other external interfaces to avoid potential concurrency in input commands.</p>
<dl class="section return"><dt>Returns</dt><dd>true if mode is switched successfully and false if not. </dd></dl>

<p>Implemented in <a class="el" href="classcontroller__interface_1_1ControllerInterface.html#a2000dfc59854737812ab54f0cfea8887">controller_interface::ControllerInterface</a>, and <a class="el" href="classcontroller__interface_1_1ChainableControllerInterface.html#ac53be760b72d721ef9528e0707ce1f4f">controller_interface::ChainableControllerInterface</a>.</p>

</div>
</div>
<a id="a3417ed9b9990df177ab116f9a7147b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3417ed9b9990df177ab116f9a7147b74">&#9670;&nbsp;</a></span>state_interface_configuration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CONTROLLER_INTERFACE_PUBLIC <a class="el" href="structcontroller__interface_1_1InterfaceConfiguration.html">InterfaceConfiguration</a> controller_interface::ControllerInterfaceBase::state_interface_configuration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get configuration for controller's required state interfaces. </p>
<p>Method used by the controller_manager to get the set of state interface used by the controller. Each controller can use individual method to determine interface names that in simples case have the following format: <code>&lt;joint&gt;/&lt;interface&gt;</code>. The method is called only in <code>inactive</code> or <code>active</code> state, i.e., <code>on_configure</code> has to be called first. The configuration is used to check if controller can be activated and to claim interfaces from hardware. The claimed interfaces are populated in the state_interface_ member.</p>
<dl class="section return"><dt>Returns</dt><dd>configuration of state interfaces. </dd></dl>

<p>Implemented in <a class="el" href="classtest__controller__with__interfaces_1_1TestControllerWithInterfaces.html#a860bdbb86e5bc8d1446b354ac49f4c00">test_controller_with_interfaces::TestControllerWithInterfaces</a>, <a class="el" href="classtest__controller__failed__init_1_1TestControllerFailedInit.html#a63f7d5f4d3ef5a4772cf698bdcf5a56d">test_controller_failed_init::TestControllerFailedInit</a>, <a class="el" href="classtest__controller_1_1TestController.html#af9cd2ea42b9e424971abfe17ce61df8e">test_controller::TestController</a>, <a class="el" href="classtest__chainable__controller_1_1TestChainableController.html#a0a89cd47a8242f7b80148537f4bd3e00">test_chainable_controller::TestChainableController</a>, <a class="el" href="classcontroller__with__options_1_1ControllerWithOptions.html#a84267b9c7c0e3f89bced0125785dad21">controller_with_options::ControllerWithOptions</a>, <a class="el" href="classTestableControllerInterface.html#afcb38c7a818191cefa23250e047d2db8">TestableControllerInterface</a>, and <a class="el" href="classTestableChainableControllerInterface.html#ab32a75d516d8b7e7f8e1a5f6ef3d6c72">TestableChainableControllerInterface</a>.</p>

</div>
</div>
<a id="add1fed599ea8a49a696ea657bf6a02b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1fed599ea8a49a696ea657bf6a02b1">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CONTROLLER_INTERFACE_PUBLIC return_type controller_interface::ControllerInterfaceBase::update </td>
          <td>(</td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rclcpp::Duration &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Control step update. Command interfaces are updated based on on reference inputs and current states. <b>The method called in the (real-time) control loop.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>The time at the start of this control loop iteration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period</td><td>The measured time taken by the last control loop iteration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return_type::OK if update is successfully, otherwise return_type::ERROR. </dd></dl>

<p>Implemented in <a class="el" href="classtest__controller__with__interfaces_1_1TestControllerWithInterfaces.html#ab299a3e05dadb42dd4175ef234d077fd">test_controller_with_interfaces::TestControllerWithInterfaces</a>, <a class="el" href="classtest__controller__failed__init_1_1TestControllerFailedInit.html#a87ad5ce8255316cfa888c7082d57e6ae">test_controller_failed_init::TestControllerFailedInit</a>, <a class="el" href="classtest__controller_1_1TestController.html#ae6d725b085d46dae05526c507d1ae3a2">test_controller::TestController</a>, <a class="el" href="classcontroller__interface_1_1ChainableControllerInterface.html#a7cc9715499c50020997f4d4f10f67d14">controller_interface::ChainableControllerInterface</a>, <a class="el" href="classcontroller__with__options_1_1ControllerWithOptions.html#a48085dbfd8217fd1c2e3855a655396ea">controller_with_options::ControllerWithOptions</a>, and <a class="el" href="classTestableControllerInterface.html#accd93dbc3e77e5f9f142037751dc7209">TestableControllerInterface</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>controller_interface/include/controller_interface/<a class="el" href="controller__interface__base_8hpp_source.html">controller_interface_base.hpp</a></li>
<li>controller_interface/src/controller_interface_base.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
